use bevy::render::mesh::{Indices, Mesh, PrimitiveTopology};

/// Generates an inverted box mesh with face UVs that fit inside a `size` square with a 1 pixel border
pub fn skybox_mesh(size: f32) -> Mesh {
    let (vertices, indices) = (
        &[
            // (+, 0, 0) Left Side
            ([01., 01., 01.], [-1., 00., 00.], [(0./6.) + (1./(6.*size+12.)), 0. + (1./(size+2.))]), // (+, +, +)
            ([01., 01., -1.], [-1., 00., 00.], [(0./6.) + (1./(6.*size+12.)), 1. - (1./(size+2.))]), // (+, +, -)
            ([01., -1., 01.], [-1., 00., 00.], [(1./6.) - (1./(6.*size+12.)), 0. + (1./(size+2.))]), // (+, -, +)
            ([01., -1., -1.], [-1., 00., 00.], [(1./6.) - (1./(6.*size+12.)), 1. - (1./(size+2.))]), // (+, -, -)
            // (0, +, 0) Top Side
            ([-1., 01., 01.], [00., -1., 00.], [(1./6.) + (1./(6.*size+12.)), 0. + (1./(size+2.))]), // (+, +, +)
            ([-1., 01., -1.], [00., -1., 00.], [(1./6.) + (1./(6.*size+12.)), 1. - (1./(size+2.))]), // (-, +, +)
            ([01., 01., 01.], [00., -1., 00.], [(2./6.) - (1./(6.*size+12.)), 0. + (1./(size+2.))]), // (+, +, -)
            ([01., 01., -1.], [00., -1., 00.], [(2./6.) - (1./(6.*size+12.)), 1. - (1./(size+2.))]), // (-, +, -)
            // (0, 0, +) Front Side
            ([01., 01., 01.], [00., 00., -1.], [(2./6.) + (1./(6.*size+12.)), 0. + (1./(size+2.))]), // (+, +, +)
            ([01., -1., 01.], [00., 00., -1.], [(2./6.) + (1./(6.*size+12.)), 1. - (1./(size+2.))]), // (+, -, +)
            ([-1., 01., 01.], [00., 00., -1.], [(3./6.) - (1./(6.*size+12.)), 0. + (1./(size+2.))]), // (-, +, +)
            ([-1., -1., 01.], [00., 00., -1.], [(3./6.) - (1./(6.*size+12.)), 1. - (1./(size+2.))]), // (-, -, +)
            // (-, 0, 0) Right Side
            ([-1., 01., 01.], [01., 00., 00.], [(3./6.) + (1./(6.*size+12.)), 0. + (1./(size+2.))]), // (-, +, +)
            ([-1., -1., 01.], [01., 00., 00.], [(3./6.) + (1./(6.*size+12.)), 1. - (1./(size+2.))]), // (-, -, +)
            ([-1., 01., -1.], [01., 00., 00.], [(4./6.) - (1./(6.*size+12.)), 0. + (1./(size+2.))]), // (-, +, -)
            ([-1., -1., -1.], [01., 00., 00.], [(4./6.) - (1./(6.*size+12.)), 1. - (1./(size+2.))]), // (-, -, -)
            // (0, -, 0) Bottom Side
            ([-1., -1., 01.], [00., 01., 00.], [(4./6.) + (1./(6.*size+12.)), 0. + (1./(size+2.))]), // (+, -, +)
            ([01., -1., 01.], [00., 01., 00.], [(4./6.) + (1./(6.*size+12.)), 1. - (1./(size+2.))]), // (+, -, -)
            ([-1., -1., -1.], [00., 01., 00.], [(5./6.) - (1./(6.*size+12.)), 0. + (1./(size+2.))]), // (-, -, +)
            ([01., -1., -1.], [00., 01., 00.], [(5./6.) - (1./(6.*size+12.)), 1. - (1./(size+2.))]), // (-, -, -)
            // (0, 0, -) Back Side
            ([01., 01., -1.], [00., 00., 01.], [(5./6.) + (1./(6.*size+12.)), 0. + (1./(size+2.))]), // (+, +, -)
            ([-1., 01., -1.], [00., 00., 01.], [(5./6.) + (1./(6.*size+12.)), 1. - (1./(size+2.))]), // (-, +, -)
            ([01., -1., -1.], [00., 00., 01.], [(6./6.) - (1./(6.*size+12.)), 0. + (1./(size+2.))]), // (+, -, -)
            ([-1., -1., -1.], [00., 00., 01.], [(6./6.) - (1./(6.*size+12.)), 1. - (1./(size+2.))]), // (-, -, -)
        ],
        &[
            00, 01, 02, 02, 01, 03, // (+, 0, 0)
            04, 05, 06, 06, 05, 07, // (0, +, 0)
            08, 09, 10, 10, 09, 11, // (0, 0, +)
            12, 13, 14, 14, 13, 15, // (-, 0, 0)
            16, 17, 18, 18, 17, 19, // (0, -, 0)
            20, 21, 22, 22, 21, 23, // (0, 0, -)
        ],
    );

    let positions: Vec<_> = vertices.iter().map(|(p, _, _)| *p).collect();
    let normals: Vec<_> = vertices.iter().map(|(_, n, _)| *n).collect();
    let uvs: Vec<_> = vertices.iter().map(|(_, _, uv)| *uv).collect();

    let mut mesh = Mesh::new(PrimitiveTopology::TriangleList);
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh.insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    mesh.set_indices(Some(Indices::U16(indices.to_vec())));
    mesh
}
